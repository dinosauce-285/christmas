<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas Wheel - Auto Remove</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Playfair+Display:wght@700;900&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020f05;
        font-family: "Mountains of Christmas", cursive;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
      }

      /* --- SIDEBAR --- */
      #side-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 260px;
        background: rgba(22, 91, 51, 0.85);
        border: 3px solid #d42426;
        border-radius: 15px;
        padding: 20px;
        z-index: 200;
        color: #fff;
        backdrop-filter: blur(5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        transition: all 0.3s ease;
      }

      #side-panel.hidden {
        transform: translateX(-100%);
        opacity: 0;
        pointer-events: none;
      }

      #side-panel h3 {
        margin: 0 0 15px 0;
        font-size: 24px;
        font-weight: 700;
        text-align: center;
        color: #f8b229;
        text-shadow: 2px 2px 0px #d42426;
        border-bottom: 2px dashed rgba(255, 255, 255, 0.3);
        padding-bottom: 10px;
      }

      #toggle-panel-btn {
        position: absolute;
        top: 20px;
        left: 300px;
        background: rgba(212, 36, 38, 0.9);
        color: #fff;
        border: 2px solid #f8b229;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        z-index: 201;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      }

      #toggle-panel-btn:hover {
        background: rgba(248, 178, 41, 0.9);
        transform: scale(1.1);
      }

      textarea#nameInput {
        width: 100%;
        height: 350px;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid #f8b229;
        border-radius: 8px;
        color: #fff;
        padding: 12px;
        font-family: "Playfair Display", serif;
        font-size: 16px;
        resize: vertical;
        box-sizing: border-box;
      }
      textarea#nameInput:focus {
        outline: none;
        border-color: #fff;
      }

      .small-guide {
        font-size: 14px;
        color: #eee;
        margin-top: 12px;
        font-style: italic;
        text-align: center;
      }

      /* Camera Preview */
      #camera-preview {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 120px;
        height: 90px;
        border: 4px solid #f8b229;
        transform: scaleX(-1);
        opacity: 0.9;
        border-radius: 10px;
        z-index: 200;
        background: #000;
        box-shadow: 0 0 15px rgba(248, 178, 41, 0.5);
      }

      #copyright {
        position: absolute;
        bottom: 10px;
        left: 20px;
        color: rgba(255, 255, 255, 0.4);
        font-size: 12px;
        pointer-events: none;
        z-index: 100;
        font-family: sans-serif;
      }
      
      /* Countdown Overlay */
      #countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        font-size: 40px;
        color: #f8b229;
        text-shadow: 0 0 10px #d42426;
        z-index: 300;
        display: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <button id="toggle-panel-btn" title="·∫®n/Hi·ªán danh s√°ch">‚óÄ</button>
    <div id="side-panel">
      <h3>üéÑ Danh S√°ch Qu√†</h3>
      <textarea id="nameInput" spellcheck="false"></textarea>
      <p class="small-guide">Nh·∫≠p t√™n ng∆∞·ªùi nh·∫≠n qu√†...</p>
    </div>

    <div id="copyright">¬© Magic Christmas</div>
    <div id="countdown-overlay"></div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // 1. DATA & CONFIG
      // ==========================================
      let nameList = [];
      let nameMeshes = [];
      let winnerIndex = -1;
      let spinProgress = 0;
      
      // -- NEW VARIABLES FOR 10S LOGIC --
      let isProcessingWinner = false; // Kh√≥a tr·∫°ng th√°i khi ƒëang hi·ªán t√™n
      let countdownTimer = null;

      const MUSIC_URL =
        "https://cdn.pixabay.com/download/audio/2022/11/22/audio_c352a382e4.mp3?filename=jingle-bells-christmas-hip-hop-126487.mp3";
      let bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 0.4;

      // --- TEXTURE GENERATORS ---
      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        const cx = 32,
          cy = 32;

        if (type === "snow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.5, "rgba(255,255,255,0.8)");
          grd.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        } else if (type === "glow_gold") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFF");
          grd.addColorStop(0.2, "#FFD700");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        } else if (type === "glow_red") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FF6666");
          grd.addColorStop(0.3, "#D42426");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        }
        return new THREE.CanvasTexture(canvas);
      }

      // 2. ELEGANT MINIMALIST NAME TAG
      function createNameTexture(name) {
        const W = 512;
        const H = 160;
        const canvas = document.createElement("canvas");
        canvas.width = W;
        canvas.height = H;
        const ctx = canvas.getContext("2d");

        // --- 1. Base ---
        const bgGrd = ctx.createLinearGradient(0, 0, 0, H);
        bgGrd.addColorStop(0, "#FFFFF0");
        bgGrd.addColorStop(1, "#F5F5DC");
        ctx.fillStyle = bgGrd;

        const r = 20;
        const x = 8;
        const y = 8;
        const w = W - 16;
        const h = H - 16;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();

        // --- 2. Inner Shadow ---
        ctx.shadowColor = "rgba(0, 0, 0, 0.08)";
        ctx.shadowBlur = 12;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.02)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(x + 2, y + 2, w - 4, h - 4, r - 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // --- 3. Border ---
        ctx.lineWidth = 3;
        const borderGrd = ctx.createLinearGradient(0, 0, W, 0);
        borderGrd.addColorStop(0, "#D4AF37");
        borderGrd.addColorStop(0.5, "#F4E5B8");
        borderGrd.addColorStop(1, "#D4AF37");
        ctx.strokeStyle = borderGrd;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.stroke();

        // --- 4. Decor ---
        ctx.fillStyle = "#D4AF37";
        const cornerSize = 8;
        ctx.beginPath(); ctx.arc(x + 15, y + 15, cornerSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + w - 15, y + 15, cornerSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + 15, y + h - 15, cornerSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + w - 15, y + h - 15, cornerSize, 0, Math.PI * 2); ctx.fill();

        // --- 5. Typography ---
        let fontSize = 70;
        if (name.length > 10) fontSize = 55;
        if (name.length > 15) fontSize = 45;

        ctx.font = `700 ${fontSize}px "Playfair Display", serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 2;
        ctx.fillStyle = "#1A1A1A";
        ctx.fillText(name, W / 2, H / 2 + 2);

        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        return tex;
      }

      const textures = {
        snow: createCustomTexture("snow"),
        gold: createCustomTexture("glow_gold"),
        red: createCustomTexture("glow_red"),
      };

      const CONFIG = {
        snowCount: 800,
        lightCount: 1000,
        ornamentCount: 300,
        treeHeight: 90,
        treeBaseRadius: 45,
      };

      let scene, camera, renderer;
      let groupSnow, groupLights, groupOrnaments;
      let groupNamesContainer;
      let titleMesh, starMesh;

      let state = "TREE";

      // ==========================================
      // 2. THREE.JS CORE
      // ==========================================
      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020f05, 0.002);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 140;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        groupSnow = createParticleSystem("snow", CONFIG.snowCount, 1.5, "SNOW");
        groupLights = createParticleSystem(
          "gold",
          CONFIG.lightCount,
          2.5,
          "TREE_LIGHTS"
        );
        groupOrnaments = createParticleSystem(
          "red",
          CONFIG.ornamentCount,
          4.0,
          "TREE_ORNAMENTS"
        );

        groupNamesContainer = new THREE.Group();
        scene.add(groupNamesContainer);

        createDecorations();
        animate();
      }

      function createParticleSystem(texType, count, size, behaviorType) {
        const positions = [];
        const velocities = [];
        const treeTargets = [];
        const explodeTargets = [];
        const sizes = [];
        const phases = [];

        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;

          let r, theta;
          if (behaviorType === "SNOW") {
            positions.push(
              (Math.random() - 0.5) * 200,
              (Math.random() - 0.5) * 100 + 50,
              (Math.random() - 0.5) * 100
            );
            velocities.push(0, -(0.05 + Math.random() * 0.1), 0);
            r = maxR * 1.5;
          } else {
            r = maxR * (0.8 + Math.random() * 0.2);
            theta = Math.random() * Math.PI * 2;
            positions.push(r * Math.cos(theta), y, r * Math.sin(theta));
            velocities.push(0, 0, 0);
          }

          theta = Math.random() * Math.PI * 2;
          treeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          const rad = 100 * Math.cbrt(Math.random());
          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          explodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );

          sizes.push(size);
          phases.push(Math.random() * Math.PI * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

        const colors = new Float32Array(count * 3);
        const baseC = new THREE.Color(
          texType === "gold"
            ? 0xffd700
            : texType === "red"
            ? 0xd42426
            : 0xffffff
        );
        for (let i = 0; i < count; i++) {
          colors[i * 3] = baseC.r;
          colors[i * 3 + 1] = baseC.g;
          colors[i * 3 + 2] = baseC.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          behavior: behaviorType,
          tree: treeTargets,
          explode: explodeTargets,
          velocities: velocities,
          phases: phases,
          baseSize: size,
        };

        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[texType],
          transparent: true,
          opacity: 0.9,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function generateNameMeshes() {
        if (!groupNamesContainer) return;
        while (groupNamesContainer.children.length > 0) {
          const c = groupNamesContainer.children[0];
          if (c.material.map) c.material.map.dispose();
          c.geometry.dispose();
          c.material.dispose();
          groupNamesContainer.remove(c);
        }
        nameMeshes = [];
        const geo = new THREE.PlaneGeometry(22, 7);

        nameList.forEach((name, i) => {
          const tex = createNameTexture(name);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.visible = false;

          const glowGeo = new THREE.PlaneGeometry(24, 9);
          const glowMat = new THREE.MeshBasicMaterial({
            color: 0x330000,
            transparent: true,
            opacity: 0.5,
            blending: THREE.MultiplyBlending,
            depthWrite: false,
          });
          const glowMesh = new THREE.Mesh(glowGeo, glowMat);
          glowMesh.position.z = -0.5;
          mesh.add(glowMesh);

          groupNamesContainer.add(mesh);
          nameMeshes.push(mesh);
        });
        if (winnerIndex >= nameList.length) winnerIndex = -1;
      }

      function createDecorations() {
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = '700 110px "Mountains of Christmas", cursive';
        ctx.fillStyle = "#F8B229";
        ctx.textAlign = "center";
        ctx.shadowColor = "#D42426";
        ctx.shadowBlur = 20;
        ctx.fillText("I-86 Gi√°ng Sinh An L√†nh", 512, 140);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
        });
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 20), mat);
        titleMesh.position.set(0, 60, 0);
        scene.add(titleMesh);

        const starCanvas = document.createElement("canvas");
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext("2d");
        sCtx.fillStyle = "#FFD700";
        sCtx.shadowColor = "#FFF";
        sCtx.shadowBlur = 30;
        sCtx.beginPath();
        const cx = 64,
          cy = 64,
          outer = 55,
          inner = 20;
        for (let i = 0; i < 5; i++) {
          sCtx.lineTo(
            cx + Math.cos(((18 + i * 72) / 180) * Math.PI) * outer,
            cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * outer
          );
          sCtx.lineTo(
            cx + Math.cos(((54 + i * 72) / 180) * Math.PI) * inner,
            cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * inner
          );
        }
        sCtx.closePath();
        sCtx.fill();
        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({
          map: starTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(18, 18), starMat);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 5, 0);
        scene.add(starMesh);
      }

      function updateParticles(group, targetState, speed, time) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const u = group.geometry.userData;
        const targets = targetState === "TREE" ? u.tree : u.explode;

        if (u.behavior === "SNOW") {
          for (let i = 0; i < positions.length / 3; i++) {
            const idx = i * 3;
            positions[idx + 1] += u.velocities[i * 3 + 1];
            positions[idx] += Math.sin(time + positions[idx + 1] * 0.1) * 0.1;
            if (positions[idx + 1] < -60) {
              positions[idx + 1] = 60;
              positions[idx] = (Math.random() - 0.5) * 150;
              positions[idx + 2] = (Math.random() - 0.5) * 100;
            }
            sizes[i] =
              u.baseSize * (0.8 + 0.4 * Math.sin(time * 2 + u.phases[i]));
          }
          group.geometry.attributes.position.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
          return;
        }

        for (let i = 0; i < positions.length / 3; i++) {
          const idx = i * 3;
          positions[idx] += (targets[idx] - positions[idx]) * speed;
          positions[idx + 1] += (targets[idx + 1] - positions[idx + 1]) * speed;
          positions[idx + 2] += (targets[idx + 2] - positions[idx + 2]) * speed;

          if (u.behavior === "TREE_LIGHTS") {
            sizes[i] =
              u.baseSize * (0.5 + 0.5 * Math.sin(time * 5 + u.phases[i]));
          }
        }
        group.geometry.attributes.position.needsUpdate = true;
        group.geometry.attributes.size.needsUpdate = true;

        if (targetState === "EXPLODE") {
          group.rotation.y -= 0.01;
        } else {
          group.rotation.y += 0.003;
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const pSpeed = 0.08;

        let pState = state === "TREE" ? "TREE" : "EXPLODE";

        updateParticles(groupSnow, pState, pSpeed, time);
        updateParticles(groupLights, pState, pSpeed, time);
        updateParticles(groupOrnaments, pState, pSpeed, time);

        if (state === "TREE") {
          titleMesh.visible = true;
          starMesh.visible = true;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
          starMesh.rotation.z = Math.sin(time) * 0.1;
          starMesh.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
          nameMeshes.forEach((m) => {
            m.visible = false;
            m.scale.set(0, 0, 0);
          });
        } else if (state === "SPIN") {
          titleMesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.15);
          starMesh.visible = false;
          if (nameList.length === 0) return;

          spinProgress += 0.15;
          const total = nameMeshes.length;
          const angleStep = (Math.PI * 2) / total;
          const radius = 55 + Math.sin(time * 3) * 2;

          nameMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = i * angleStep - spinProgress;
            const x = Math.sin(angle) * radius;
            const z = Math.cos(angle) * radius;
            const y = Math.cos(angle * 2 + time * 4) * 5;

            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.2);
            mesh.quaternion.copy(camera.quaternion);
            mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            mesh.material.opacity = 1.0;
          });
        } else if (state === "RESULT") {
          if (nameList.length === 0 || winnerIndex === -1) return;

          nameMeshes.forEach((mesh, i) => {
            if (i === winnerIndex) {
              mesh.visible = true;
              mesh.position.lerp(new THREE.Vector3(0, 0, 90), 0.1);
              mesh.quaternion.copy(camera.quaternion);

              const pulse = 3.5 + Math.sin(time * 10) * 0.2;
              mesh.scale.lerp(new THREE.Vector3(pulse, pulse, pulse), 0.1);
              mesh.rotation.z = Math.sin(time * 5) * 0.05;
            } else {
              mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }
        renderer.render(scene, camera);
      }

      // ==========================================
      // 3. HAND & INPUT
      // ==========================================
      function updateNamesFromInput() {
        const input = document.getElementById("nameInput");
        const newNames = input.value
          .split(/\r?\n/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        if (newNames.join("|") !== nameList.join("|")) {
          nameList = newNames;
          if (nameList.length === 0) nameList = ["..."];
          generateNameMeshes();
        }
      }

      function startSystem() {
        document.body.addEventListener(
          "click",
          () => {
            bgMusic.play().catch(() => {});
          },
          { once: true }
        );

        // Toggle panel button
        const toggleBtn = document.getElementById("toggle-panel-btn");
        const sidePanel = document.getElementById("side-panel");
        let isPanelVisible = true;

        toggleBtn.addEventListener("click", () => {
          isPanelVisible = !isPanelVisible;
          if (isPanelVisible) {
            sidePanel.classList.remove("hidden");
            toggleBtn.textContent = "‚óÄ";
            toggleBtn.style.left = "300px";
          } else {
            sidePanel.classList.add("hidden");
            toggleBtn.textContent = "‚ñ∂";
            toggleBtn.style.left = "20px";
          }
        });

        init3D();
        updateNamesFromInput();
        document
          .getElementById("nameInput")
          .addEventListener("input", updateNamesFromInput);

        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        const ctx = canvas.getContext("2d");

        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 0,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6,
        });

        // --- WINNER HANDLING LOGIC ---
        function startWinnerCountdown() {
            isProcessingWinner = true; // LOCK STATE
            
            // Show overlay timer logic if needed, currently just waits
            const overlay = document.getElementById("countdown-overlay");
            if(overlay) {
                overlay.style.display = "block";
            }

            // 10 SECONDS TIMER
            setTimeout(() => {
                removeWinnerAndReset();
            }, 10000); // 10000 ms = 10s
        }

        function removeWinnerAndReset() {
            // Remove winner from list
            if (winnerIndex > -1 && winnerIndex < nameList.length) {
                nameList.splice(winnerIndex, 1);
            }

            // Update Textarea
            document.getElementById("nameInput").value = nameList.join("\n");
            
            // Re-sync global nameList just in case
            if (nameList.length === 0) nameList = ["..."];

            // Reset Logic
            winnerIndex = -1;
            generateNameMeshes();
            
            // Reset UI
            const overlay = document.getElementById("countdown-overlay");
            if(overlay) overlay.style.display = "none";

            // Unlock State
            state = "TREE";
            isProcessingWinner = false;
        }

        hands.onResults((results) => {
          ctx.clearRect(0, 0, 100, 75);
          if (results.image) ctx.drawImage(results.image, 0, 0, 100, 75);
          
          // !!! QUAN TR·ªåNG: N·∫øu ƒëang ƒë·∫øm ng∆∞·ª£c 10s th√¨ kh√¥ng nh·∫≠n di·ªán tay n·ªØa
          if (isProcessingWinner) return;

          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const tips = [8, 12, 16, 20];
            const wrist = lm[0];
            let openDist = 0;
            tips.forEach(
              (i) =>
                (openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y))
            );
            const avgDist = openDist / 4;

            if (avgDist > 0.28) {
              state = "SPIN";
              winnerIndex = -1;
            } else if (avgDist < 0.18) {
              // N·∫Øm tay l·∫°i -> K·∫øt qu·∫£
              state = "RESULT";
              if (
                winnerIndex === -1 &&
                nameList.length > 0 &&
                nameList[0] !== "..."
              ) {
                winnerIndex = Math.floor(Math.random() * nameList.length);
                // B·∫Øt ƒë·∫ßu quy tr√¨nh 10s
                startWinnerCountdown();
              }
            } else {
              if (state === "TREE") state = "SPIN";
            }
          } else {
            state = "TREE";
            winnerIndex = -1;
          }
        });

        const cameraUtils = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240,
        });
        cameraUtils.start();
      }

      window.addEventListener("load", startSystem);
      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>