<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas Wheel - Auto Remove</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Playfair+Display:wght@700;900&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020f05;
        font-family: "Mountains of Christmas", cursive;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
      }

      /* --- SIDEBAR --- */
      #side-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 260px;
        background: rgba(22, 91, 51, 0.85);
        border: 3px solid #d42426;
        border-radius: 15px;
        padding: 20px;
        z-index: 200;
        color: #fff;
        backdrop-filter: blur(5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        transition: all 0.3s ease;
      }

      #side-panel.hidden {
        transform: translateX(-100%);
        opacity: 0;
        pointer-events: none;
      }

      #side-panel h3 {
        margin: 0 0 15px 0;
        font-size: 24px;
        font-weight: 700;
        text-align: center;
        color: #f8b229;
        text-shadow: 2px 2px 0px #d42426;
        border-bottom: 2px dashed rgba(255, 255, 255, 0.3);
        padding-bottom: 10px;
      }

      #toggle-panel-btn {
        position: absolute;
        top: 20px;
        left: 300px;
        background: rgba(212, 36, 38, 0.9);
        color: #fff;
        border: 2px solid #f8b229;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        z-index: 201;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      }

      #toggle-panel-btn:hover {
        background: rgba(248, 178, 41, 0.9);
        transform: scale(1.1);
      }

      textarea#nameInput {
        width: 100%;
        height: 350px;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid #f8b229;
        border-radius: 8px;
        color: #fff;
        padding: 12px;
        font-family: "Playfair Display", serif;
        font-size: 16px;
        resize: vertical;
        box-sizing: border-box;
      }
      textarea#nameInput:focus {
        outline: none;
        border-color: #fff;
      }

      .small-guide {
        font-size: 14px;
        color: #eee;
        margin-top: 12px;
        font-style: italic;
        text-align: center;
      }

      /* Camera Preview */
      #camera-preview {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 120px;
        height: 90px;
        border: 4px solid #f8b229;
        transform: scaleX(-1);
        opacity: 0.9;
        border-radius: 10px;
        z-index: 200;
        background: #000;
        box-shadow: 0 0 15px rgba(248, 178, 41, 0.5);
      }

      #copyright {
        position: absolute;
        bottom: 10px;
        left: 20px;
        color: rgba(255, 255, 255, 0.4);
        font-size: 12px;
        pointer-events: none;
        z-index: 100;
        font-family: sans-serif;
      }

      /* Countdown Overlay */
      #countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        font-size: 40px;
        color: #f8b229;
        text-shadow: 0 0 10px #d42426;
        z-index: 300;
        display: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <button id="toggle-panel-btn" title="áº¨n/Hiá»‡n danh sÃ¡ch">â—€</button>
    <div id="side-panel">
      <h3>ðŸŽ„ Danh SÃ¡ch QuÃ </h3>
      <textarea id="nameInput" spellcheck="false"></textarea>
      <p class="small-guide">Nháº­p sá»‘ thá»© tá»± quÃ ...</p>
    </div>

    <div id="copyright">Â© Magic Christmas</div>
    <div id="countdown-overlay"></div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // 1. DATA & CONFIG (ÄÃ£ cáº­p nháº­t Audio & Smoothing)
      // ==========================================
      let nameList = [];
      let nameMeshes = [];
      let winnerIndex = -1;
      let spinProgress = 0;

      let isProcessingWinner = false;
      let countdownTimer = null;

      // --- Cáº¬P NHáº¬T: Nháº¡c ná»n cá»¥c bá»™ ---
      const bgMusic = new Audio("audio.mp3");
      bgMusic.loop = true;
      bgMusic.volume = 0.4;

      // --- Cáº¬P NHáº¬T: Biáº¿n chá»‘ng nhiá»…u (Smoothing) ---
      let gestureBuffer = [];
      const BUFFER_SIZE = 5; // LÆ°u 5 khung hÃ¬nh gáº§n nháº¥t Ä‘á»ƒ láº¥y káº¿t quáº£ trung bÃ¬nh

      // --- TEXTURE GENERATORS ---
      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        const cx = 32,
          cy = 32;

        if (type === "snow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.5, "rgba(255,255,255,0.8)");
          grd.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        } else if (type === "glow_gold") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFF");
          grd.addColorStop(0.2, "#FFD700");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        } else if (type === "glow_red") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FF6666");
          grd.addColorStop(0.3, "#D42426");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 64, 64);
        }
        return new THREE.CanvasTexture(canvas);
      }

      function createNameTexture(name) {
        const W = 512;
        const H = 160;
        const canvas = document.createElement("canvas");
        canvas.width = W;
        canvas.height = H;
        const ctx = canvas.getContext("2d");
        const bgGrd = ctx.createLinearGradient(0, 0, 0, H);
        bgGrd.addColorStop(0, "#FFFFF0");
        bgGrd.addColorStop(1, "#F5F5DC");
        ctx.fillStyle = bgGrd;
        const r = 20;
        const x = 8;
        const y = 8;
        const w = W - 16;
        const h = H - 16;
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();
        ctx.lineWidth = 3;
        const borderGrd = ctx.createLinearGradient(0, 0, W, 0);
        borderGrd.addColorStop(0, "#D4AF37");
        borderGrd.addColorStop(0.5, "#F4E5B8");
        borderGrd.addColorStop(1, "#D4AF37");
        ctx.strokeStyle = borderGrd;
        ctx.stroke();
        let fontSize = 70;
        if (name.length > 10) fontSize = 55;
        if (name.length > 15) fontSize = 45;
        ctx.font = `700 ${fontSize}px "Playfair Display", serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#1A1A1A";
        ctx.fillText(name, W / 2, H / 2 + 2);
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        return tex;
      }

      const textures = {
        snow: createCustomTexture("snow"),
        gold: createCustomTexture("glow_gold"),
        red: createCustomTexture("glow_red"),
      };

      const CONFIG = {
        snowCount: 800,
        lightCount: 1000,
        ornamentCount: 300,
        treeHeight: 90,
        treeBaseRadius: 45,
      };

      let scene,
        camera,
        renderer,
        groupSnow,
        groupLights,
        groupOrnaments,
        groupNamesContainer,
        titleMesh,
        starMesh;
      let state = "TREE";

      // ==========================================
      // 2. THREE.JS CORE
      // ==========================================
      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020f05, 0.002);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 140;
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        groupSnow = createParticleSystem("snow", CONFIG.snowCount, 1.5, "SNOW");
        groupLights = createParticleSystem(
          "gold",
          CONFIG.lightCount,
          2.5,
          "TREE_LIGHTS"
        );
        groupOrnaments = createParticleSystem(
          "red",
          CONFIG.ornamentCount,
          4.0,
          "TREE_ORNAMENTS"
        );
        groupNamesContainer = new THREE.Group();
        scene.add(groupNamesContainer);

        createDecorations();
        animate();
      }

      function createParticleSystem(texType, count, size, behaviorType) {
        const positions = [];
        const velocities = [];
        const treeTargets = [];
        const explodeTargets = [];
        const sizes = [];
        const phases = [];
        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          let r, theta;
          if (behaviorType === "SNOW") {
            positions.push(
              (Math.random() - 0.5) * 200,
              (Math.random() - 0.5) * 100 + 50,
              (Math.random() - 0.5) * 100
            );
            velocities.push(0, -(0.05 + Math.random() * 0.1), 0);
            r = maxR * 1.5;
          } else {
            r = maxR * (0.8 + Math.random() * 0.2);
            theta = Math.random() * Math.PI * 2;
            positions.push(r * Math.cos(theta), y, r * Math.sin(theta));
            velocities.push(0, 0, 0);
          }
          theta = Math.random() * Math.PI * 2;
          treeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));
          const rad = 100 * Math.cbrt(Math.random());
          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          explodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );
          sizes.push(size);
          phases.push(Math.random() * Math.PI * 2);
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
        const colors = new Float32Array(count * 3);
        const baseC = new THREE.Color(
          texType === "gold"
            ? 0xffd700
            : texType === "red"
            ? 0xd42426
            : 0xffffff
        );
        for (let i = 0; i < count; i++) {
          colors[i * 3] = baseC.r;
          colors[i * 3 + 1] = baseC.g;
          colors[i * 3 + 2] = baseC.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geo.userData = {
          behavior: behaviorType,
          tree: treeTargets,
          explode: explodeTargets,
          velocities: velocities,
          phases: phases,
          baseSize: size,
        };
        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[texType],
          transparent: true,
          opacity: 0.9,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function generateNameMeshes() {
        if (!groupNamesContainer) return;
        while (groupNamesContainer.children.length > 0) {
          const c = groupNamesContainer.children[0];
          if (c.material.map) c.material.map.dispose();
          c.geometry.dispose();
          c.material.dispose();
          groupNamesContainer.remove(c);
        }
        nameMeshes = [];
        const geo = new THREE.PlaneGeometry(22, 7);
        nameList.forEach((name, i) => {
          const tex = createNameTexture(name);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.visible = false;
          const glowMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(24, 9),
            new THREE.MeshBasicMaterial({
              color: 0x330000,
              transparent: true,
              opacity: 0.5,
              blending: THREE.MultiplyBlending,
              depthWrite: false,
            })
          );
          glowMesh.position.z = -0.5;
          mesh.add(glowMesh);
          groupNamesContainer.add(mesh);
          nameMeshes.push(mesh);
        });
      }

      function createDecorations() {
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = '700 110px "Mountains of Christmas", cursive';
        ctx.fillStyle = "#F8B229";
        ctx.textAlign = "center";
        ctx.shadowColor = "#D42426";
        ctx.shadowBlur = 20;
        ctx.fillText("I-86 GiÃ¡ng Sinh An LÃ nh", 512, 140);
        titleMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(80, 20),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
          })
        );
        titleMesh.position.set(0, 60, 0);
        scene.add(titleMesh);

        const starCanvas = document.createElement("canvas");
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext("2d");
        sCtx.fillStyle = "#FFD700";
        sCtx.beginPath();
        const cx = 64,
          cy = 64,
          outer = 55,
          inner = 20;
        for (let i = 0; i < 5; i++) {
          sCtx.lineTo(
            cx + Math.cos(((18 + i * 72) / 180) * Math.PI) * outer,
            cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * outer
          );
          sCtx.lineTo(
            cx + Math.cos(((54 + i * 72) / 180) * Math.PI) * inner,
            cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * inner
          );
        }
        sCtx.closePath();
        sCtx.fill();
        starMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(18, 18),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(starCanvas),
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 5, 0);
        scene.add(starMesh);
      }

      function updateParticles(group, targetState, speed, time) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const u = group.geometry.userData;
        const targets = targetState === "TREE" ? u.tree : u.explode;

        if (u.behavior === "SNOW") {
          for (let i = 0; i < positions.length / 3; i++) {
            const idx = i * 3;
            positions[idx + 1] += u.velocities[i * 3 + 1];
            positions[idx] += Math.sin(time + positions[idx + 1] * 0.1) * 0.1;
            if (positions[idx + 1] < -60) {
              positions[idx + 1] = 60;
              positions[idx] = (Math.random() - 0.5) * 150;
              positions[idx + 2] = (Math.random() - 0.5) * 100;
            }
          }
          group.geometry.attributes.position.needsUpdate = true;
          return;
        }

        for (let i = 0; i < positions.length / 3; i++) {
          const idx = i * 3;
          positions[idx] += (targets[idx] - positions[idx]) * speed;
          positions[idx + 1] += (targets[idx + 1] - positions[idx + 1]) * speed;
          positions[idx + 2] += (targets[idx + 2] - positions[idx + 2]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;
        group.rotation.y += targetState === "EXPLODE" ? -0.01 : 0.003;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const pSpeed = 0.08;
        let pState = state === "TREE" ? "TREE" : "EXPLODE";

        updateParticles(groupSnow, pState, pSpeed, time);
        updateParticles(groupLights, pState, pSpeed, time);
        updateParticles(groupOrnaments, pState, pSpeed, time);

        if (state === "TREE") {
          titleMesh.visible = true;
          starMesh.visible = true;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
          nameMeshes.forEach((m) => {
            m.visible = false;
            m.scale.set(0, 0, 0);
          });
        } else if (state === "SPIN") {
          titleMesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.15);
          starMesh.visible = false;
          if (nameList.length > 0) {
            spinProgress += 0.15;
            const angleStep = (Math.PI * 2) / nameMeshes.length;
            nameMeshes.forEach((mesh, i) => {
              mesh.visible = true;
              const angle = i * angleStep - spinProgress;
              const x = Math.sin(angle) * 55;
              const z = Math.cos(angle) * 55;
              mesh.position.lerp(
                new THREE.Vector3(x, Math.cos(angle * 2 + time * 4) * 5, z),
                0.2
              );
              mesh.quaternion.copy(camera.quaternion);
              mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            });
          }
        } else if (state === "RESULT") {
          if (winnerIndex !== -1) {
            nameMeshes.forEach((mesh, i) => {
              if (i === winnerIndex) {
                mesh.visible = true;
                mesh.position.lerp(new THREE.Vector3(0, 0, 90), 0.1);
                mesh.quaternion.copy(camera.quaternion);
                const pulse = 3.5 + Math.sin(time * 10) * 0.2;
                mesh.scale.lerp(new THREE.Vector3(pulse, pulse, pulse), 0.1);
              } else {
                mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
              }
            });
          }
        }
        renderer.render(scene, camera);
      }

      // ==========================================
      // 3. HAND & INPUT (Cáº­p nháº­t Smoothing Logic)
      // ==========================================
      function updateNamesFromInput() {
        const input = document.getElementById("nameInput");
        const newNames = input.value
          .split(/\r?\n/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        if (newNames.join("|") !== nameList.join("|")) {
          nameList = newNames;
          if (nameList.length === 0) nameList = ["..."];
          generateNameMeshes();
        }
      }

      function startWinnerCountdown() {
        isProcessingWinner = true;
        const overlay = document.getElementById("countdown-overlay");
        if (overlay) overlay.style.display = "block";
        setTimeout(() => {
          if (winnerIndex > -1 && winnerIndex < nameList.length)
            nameList.splice(winnerIndex, 1);
          document.getElementById("nameInput").value = nameList.join("\n");
          winnerIndex = -1;
          generateNameMeshes();
          if (overlay) overlay.style.display = "none";
          state = "TREE";
          isProcessingWinner = false;
          gestureBuffer = []; // Reset buffer sau khi xong
        }, 10000);
      }

      function startSystem() {
        // --- Cáº¬P NHáº¬T: KÃ­ch hoáº¡t nháº¡c khi click ---
        document.body.addEventListener(
          "click",
          () => {
            bgMusic.play().catch((e) => console.log("Audio play blocked"));
          },
          { once: true }
        );

        init3D();
        updateNamesFromInput();
        document
          .getElementById("nameInput")
          .addEventListener("input", updateNamesFromInput);

        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        const ctx = canvas.getContext("2d");
        canvas.width = 320;
        canvas.height = 240;
        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 0,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6,
        });

        hands.onResults((results) => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          if (isProcessingWinner) return;

          let rawState = "TREE";
          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const tips = [8, 12, 16, 20];
            const wrist = lm[0];
            let openDist = 0;
            tips.forEach(
              (i) =>
                (openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y))
            );
            const avgDist = openDist / 4;

            if (avgDist > 0.28) rawState = "SPIN";
            else if (avgDist < 0.22) rawState = "RESULT";
            else rawState = "SPIN"; // Tráº¡ng thÃ¡i chuyá»ƒn giao
          } else {
            rawState = "TREE";
          }

          // --- Cáº¬P NHáº¬T: Smoothing Buffer ---
          gestureBuffer.push(rawState);
          if (gestureBuffer.length > BUFFER_SIZE) gestureBuffer.shift();

          // Láº¥y tráº¡ng thÃ¡i xuáº¥t hiá»‡n nhiá»u nháº¥t trong buffer
          const counts = {};
          gestureBuffer.forEach((s) => (counts[s] = (counts[s] || 0) + 1));
          const smoothedState = Object.keys(counts).reduce((a, b) =>
            counts[a] > counts[b] ? a : b
          );

          // Cáº­p nháº­t state chÃ­nh tá»« smoothedState
          if (smoothedState === "RESULT" && state !== "RESULT") {
            state = "RESULT";
            if (
              winnerIndex === -1 &&
              nameList.length > 0 &&
              nameList[0] !== "..."
            ) {
              winnerIndex = Math.floor(Math.random() * nameList.length);
              startWinnerCountdown();
            }
          } else if (state !== "RESULT") {
            state = smoothedState;
          }
        });

        new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240,
        }).start();
      }

      window.addEventListener("load", startSystem);
      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
